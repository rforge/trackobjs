<html><head><title>Potential future features of the trackObjs package</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>track.future(trackObjs)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   track.future">
<param name="keyword" value=" Potential future features of the trackObjs package">
</object>


<h2>Potential future features of the trackObjs package</h2>


<h3>Description</h3>

<p>
Potential future features of the trackObjs package, in some vague order
of feasibility and priority ('easy', 'medium' and 'hard' are an estimate
of design and coding difficulty):
</p>

<dl>
<dt>untracked variables in the summary:</dt><dd>(easy) would this be useful?
wouldn't need to cache these, mark with an asterisk in a special
column?</dd>
<dt>other default tracked environment:</dt><dd>(easy) would it be useful to allow
an environment other than the global environment to be the
default tracking environment?  This could be implemented by using
<code>options("tracked.environment")</code> as the default environment for all the
tracking functions (rather than the currently hardcoded pos=1)</dd>
<dt>better cleanup:</dt><dd>(easy) provide an integrated quiting function that
saves all tracked vars and history before quitting (and maybe also
saves untracked vars in an RData file)</dd>
<dt>caching rules:</dt><dd>(hard) allow rule-based decisions for caching, e.g.,
only cache objects under a certain size, or only cache objects of
certain classes, or enforce a limit on memory for caching tracked
variables, and flush out least-recently used variables</dd>
<dt>auto-trust in rebuild:</dt><dd>(easy) when rebuilding an active tracking
environment, base decision whether to use summary row from file or
environment on which has more recent dates in it. (whole dataframe,
or row by row?)</dd>
<dt>smarter reading of filemap.txt:</dt><dd>(medium) check the mod time on
filemap.txt when getting the filemap obj, and if the file on disk
appears to have changed, reread it instead of just getting it from
memory.  This would allow working together better with other
sessions that are simultaneously using this tracking dir.  Don't know how much
it would slow things down &ndash; do some timings.  Note that to make
this work in a fool-proof manner would require locks.</dd>
<dt>investigate double-get:</dt><dd>doing subset-replacement (e.g.,
<code>X[2] &lt;- ...</code>) retrieves <code>X</code> twice
(see example below)</dd>
<dt>readonly mode:</dt><dd>(hard) to allow linking tracking dirs that might be
in use by other R processes &ndash; would require not recording
gets &ndash; this would require adding a new env on the
search path and tracking it</dd>
<dt>autoflush:</dt><dd>(hard) automatic flushing of variables that haven't been used
frequently (triggered automaticall when memory runs low?) &ndash; this
is why the summary records fetches as well as writes</dd>
<dt>safer restart:</dt><dd>(medium) check that we will be able to restart before
doing the stop (check for masked variables or other potential clobber problems)</dd>
<dt>safe saves:</dt><dd>(hard) write files in a safe way so that the original
file is not removed until the new file is written &ndash; not sure if
this is necessary, because objects are in memory, and can be
rewritten if there is a failure</dd>
<dt>autotrack:</dt><dd>(hard) automatically track new variables? (would require hooks in
base-R that get called when a new var is created)</dd>
</dl>

<p>
Example of the "double-get" when assigning a subset (using the example
from the help page for <code>makeActiveBinding</code>).  Note that it works
correctly, but retrieving the object twice seems unneccessary and could
be slow with very large objects.
</p>
<pre>
&gt; f &lt;- local( {
+     x &lt;- 1
+     function(v) {
+        if (missing(v))
+            cat("get\n")
+        else {
+            cat("set\n")
+            x &lt;&lt;- v
+        }
+        x
+     }
+ })
&gt; makeActiveBinding("X", f, .GlobalEnv)
NULL
&gt; bindingIsActive("X", .GlobalEnv)
[1] TRUE
&gt; X
get
[1] 1
&gt; X &lt;- 2
set
&gt; X
get
[1] 2
&gt; 
&gt; X[1]
get
[1] 2
&gt; X[2] &lt;- 1 # 'X' is fetched twice
get
get
set
&gt; X
get
[1] 2 1
&gt;
</pre>
</p>


<h3>See Also</h3>

<p>
design of the <code>trackObjs</code> package.
</p>


<h3>Examples</h3>

<pre>
# Example (transcript shown above) of how subset-assignment
# results in two retrievals when the object is an active binding.
f &lt;- local( {
    x &lt;- 1
    function(v) {
       if (missing(v)) {
           cat("get\n")
       } else {
           cat("set\n")
           x &lt;&lt;- v
       }
       x
    }
})
makeActiveBinding("X", f, .GlobalEnv)
bindingIsActive("X", .GlobalEnv)
X
X &lt;- 2
X
X[1]
X[2] &lt;- 1 # 'X' is fetched twice
X
</pre>



<hr><div align="center">[Package <em>trackObjs</em> version 0.8-3 <a href="00Index.html">Index</a>]</div>

</body></html>
